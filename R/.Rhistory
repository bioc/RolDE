}
getCommonRange<-function(temp_time1, temp_time2){
if(min(temp_time2)>(min(temp_time1))){global_min<-min(temp_time2)}else{global_min<-min(temp_time1)}
if(max(temp_time2)<(max(temp_time1))){global_max<-max(temp_time2)}else{global_max<-max(temp_time1)}
return(list(global_min, global_max))
}
r.sim=unlist(lapply(b, function(x) getRank(a, s=x)))
summary(r)
summary(r.sim)
dd=matrix(nrow = 1000, ncol = 1000)
dd=matrix(nrow = 1000, ncol = 1000)
for(i in 1:1000){
b=sample(p.vals, 1000, replace = T)
r.sim=unlist(lapply(b, function(x) getRank(a, s=x)))
dd[i,]=r.sim
}
summary(as.numeric(unlist(dd)))
summary(r)
plot(density(r))
lines(density(as.numeric(unlist(dd))))
plot(as.numeric(r))
plot(sort(as.numeric(r)))
lines(sort(as.numeric(unlist(dd))), col=2)
hist(r)
hist(dd)
libray(RolDe)
library(RolDE)
RolDE()
#Try out
load("C:/data/Seafile/My Library/Longitudinal Proteomics/RolDE/Test_Battery_For_RolDE_17_9_2020.RData")
data_descrptions
r=7
data=get(as.character(parameters[r,1]))
des_matrix=get(as.character(parameters[r,2]))
aligned<-as.logical(parameters[r,3])
polyregType<-as.character(parameters[r,4])
na_treat<-as.character(parameters[r,5])
mix_degree<-as.numeric(as.character(parameters[r,6]))
res=RolDE(data = data, des_matrix = des_matrix, doPar = F, n_cores = 1, aligned = aligned, polyregType = polyregType, mix_degree = mix_degree, na_treat = na_treat)
?lm
a=c(2.3, 4.5,2.2,2.9)
2*a
(2*a)/2
2*a
(2*a)/(2*4)
a/4
library(RolDE)
data("des_matrix1")
dim(des_matrix1)
install.packages("knitr")
install.packages('knitr', repos = c('http://yihui.name/xran', 'http://cran.rstudio.org'))
install.packages("knitr", repos = c("http://yihui.name/xran", "http://cran.rstudio.org"))
library(knitr)
knitr::knit_hooks$set(evaluate = evaluate::evaluate)
devtools::install_github("https://github.com/yihui/knitr")
devtools::install_github("https://github.com/yihui/knitr")
devtools::install_github("https://github.com/yihui/knitr")
devtools::install_github("https://github.com/yihui/knitr")
install.packages("glue")
install.packages("glue")
install.packages("glue")
install.packages("glue")
install.packages("glue")
devtools::install_github("https://github.com/yihui/knitr")
install.packages("yaml")
devtools::install_github("https://github.com/yihui/knitr")
library(knitr)
library(evaluate)
evaluate
evaluate:::evaluate_call
packageurl <- "http://cran.r-project.org/src/contrib/Archive/knitr/knitr_1.12.tar.gz"
install.packages(packageurl, repos=NULL, type="source")
library(knitr)
devtools::install_github("https://github.com/yihui/knitr")
library(knitr)
library(evaluate)
library(knitr)
sessionInfo()
install.packages(c("ade4", "amap", "ape", "arm", "backports", "BH", "bibtex", "BiocManager", "bit", "bit64", "blob", "boot", "broom", "callr", "car", "carData", "caret", "caTools", "checkmate", "ClassDiscovery", "cli", "clipr", "coda", "colorspace", "cowplot", "crosstalk", "curl", "data.table", "DBI", "ddalpha", "digest", "distances", "doParallel", "doSNOW", "dplyr", "DRR", "DT", "e1071", "effects", "EnvStats", "fansi", "ff", "fit.models", "forcats", "foreach", "Formula", "fs", "gargle", "gbm", "generics", "geometry", "ggplot2", "ggrepel", "git2r", "glmnet", "gmp", "gower", "gplots", "gridGraphics", "gtools", "haven", "hexbin", "Hmisc", "hms", "htmlTable", "htmltools", "htmlwidgets", "httpuv", "igraph", "iterators", "kernlab", "labeling", "lambda.r", "later", "latticeExtra", "lava", "lifecycle", "lintr", "lme4", "lmerTest", "locfit", "lpSolve", "lubridate", "manipulateWidget", "maptools", "matrixStats", "mclust", "mixtools", "mnormt", "ModelMetrics", "monomvn", "mvtnorm", "naivebayes", "nlme", "nloptr", "openssl", "openxlsx", "pbkrtest", "pillar", "pkgconfig", "plotly", "plotrix", "pls", "plyr", "prettyunits", "pROC", "processx", "prodlim", "promises", "ps", "psych", "pvclust", "quadprog", "quantreg", "R.methodsS3", "R.oo", "R.utils", "R6", "ranger", "raster", "Rcmdr", "RcmdrMisc", "Rcpp", "RcppArmadillo", "RcppEigen", "RcppProgress", "RCurl", "readr", "recipes", "rematch2", "reshape2", "rex", "rJava", "rlang", "rmarkdown", "Rmpfr", "RMySQL", "robust", "robustbase", "rprojroot", "rrcov", "RSQLite", "rstudioapi", "sandwich", "scales", "segmented", "seqinr", "sfsmisc", "shape", "shiny", "sp", "SparseM", "SQUAREM", "statmod", "stringdist", "survey", "sys", "testthat", "tibble", "tidyr", "tidyselect", "TTR", "vctrs", "webshot", "venn", "WGCNA", "vioplot", "xlsx", "XML", "xml2", "xts", "zip", "zoo"))
install.packages(c("ade4", "amap", "ape", "arm", "backports", "BH", "bibtex", "BiocManager", "bit", "bit64", "blob", "boot", "broom", "callr", "car", "carData", "caret", "caTools", "checkmate", "ClassDiscovery", "cli", "clipr", "coda", "colorspace", "cowplot", "crosstalk", "curl", "data.table", "DBI", "ddalpha", "digest", "distances", "doParallel", "doSNOW", "dplyr", "DRR", "DT", "e1071", "effects", "EnvStats", "fansi", "ff", "fit.models", "forcats", "foreach", "Formula", "fs", "gargle", "gbm", "generics", "geometry", "ggplot2", "ggrepel", "git2r", "glmnet", "gmp", "gower", "gplots", "gridGraphics", "gtools", "haven", "hexbin", "Hmisc", "hms", "htmlTable", "htmltools", "htmlwidgets", "httpuv", "igraph", "iterators", "kernlab", "labeling", "lambda.r", "later", "latticeExtra", "lava", "lifecycle", "lintr", "lme4", "lmerTest", "locfit", "lpSolve", "lubridate", "manipulateWidget", "maptools", "matrixStats", "mclust", "mixtools", "mnormt", "ModelMetrics", "monomvn", "mvtnorm", "naivebayes", "nlme", "nloptr", "openssl", "openxlsx", "pbkrtest", "pillar", "pkgconfig", "plotly", "plotrix", "pls", "plyr", "prettyunits", "pROC", "processx", "prodlim", "promises", "ps", "psych", "pvclust", "quadprog", "quantreg", "R.methodsS3", "R.oo", "R.utils", "R6", "ranger", "raster", "Rcmdr", "RcmdrMisc", "Rcpp", "RcppArmadillo", "RcppEigen", "RcppProgress", "RCurl", "readr", "recipes", "rematch2", "reshape2", "rex", "rJava", "rlang", "rmarkdown", "Rmpfr", "RMySQL", "robust", "robustbase", "rprojroot", "rrcov", "RSQLite", "rstudioapi", "sandwich", "scales", "segmented", "seqinr", "sfsmisc", "shape", "shiny", "sp", "SparseM", "SQUAREM", "statmod", "stringdist", "survey", "sys", "testthat", "tibble", "tidyr", "tidyselect", "TTR", "vctrs", "webshot", "venn", "WGCNA", "vioplot", "xlsx", "XML", "xml2", "xts", "zip", "zoo"))
install.packages(c("ade4", "amap", "ape", "arm", "backports", "BH", "bibtex", "BiocManager", "bit", "bit64", "blob", "boot", "broom", "callr", "car", "carData", "caret", "caTools", "checkmate", "ClassDiscovery", "cli", "clipr", "coda", "colorspace", "cowplot", "crosstalk", "curl", "data.table", "DBI", "ddalpha", "digest", "distances", "doParallel", "doSNOW", "dplyr", "DRR", "DT", "e1071", "effects", "EnvStats", "fansi", "ff", "fit.models", "forcats", "foreach", "Formula", "fs", "gargle", "gbm", "generics", "geometry", "ggplot2", "ggrepel", "git2r", "glmnet", "gmp", "gower", "gplots", "gridGraphics", "gtools", "haven", "hexbin", "Hmisc", "hms", "htmlTable", "htmltools", "htmlwidgets", "httpuv", "igraph", "iterators", "kernlab", "labeling", "lambda.r", "later", "latticeExtra", "lava", "lifecycle", "lintr", "lme4", "lmerTest", "locfit", "lpSolve", "lubridate", "manipulateWidget", "maptools", "matrixStats", "mclust", "mixtools", "mnormt", "ModelMetrics", "monomvn", "mvtnorm", "naivebayes", "nlme", "nloptr", "openssl", "openxlsx", "pbkrtest", "pillar", "pkgconfig", "plotly", "plotrix", "pls", "plyr", "prettyunits", "pROC", "processx", "prodlim", "promises", "ps", "psych", "pvclust", "quadprog", "quantreg", "R.methodsS3", "R.oo", "R.utils", "R6", "ranger", "raster", "Rcmdr", "RcmdrMisc", "Rcpp", "RcppArmadillo", "RcppEigen", "RcppProgress", "RCurl", "readr", "recipes", "rematch2", "reshape2", "rex", "rJava", "rlang", "rmarkdown", "Rmpfr", "RMySQL", "robust", "robustbase", "rprojroot", "rrcov", "RSQLite", "rstudioapi", "sandwich", "scales", "segmented", "seqinr", "sfsmisc", "shape", "shiny", "sp", "SparseM", "SQUAREM", "statmod", "stringdist", "survey", "sys", "testthat", "tibble", "tidyr", "tidyselect", "TTR", "vctrs", "webshot", "venn", "WGCNA", "vioplot", "xlsx", "XML", "xml2", "xts", "zip", "zoo"))
library(RolDE)
?RolDE
Sys.setenv("R_REMOTES_NO_ERRORS_FROM_WARNINGS" = "true")
devtools:::install_gitlab(repo = "elolab/rolde", host = "gitlab.utu.fi", dependencies = T, auth_token = "eh7LLTZAET4oMmK_NLe7", build_vignettes = T, force = T)
library(RolDE)
browseVignettes("RolDE")
library(RolDE)
?RolDE
browseVignettes("RolDE")
data("data4")
data("des_matrix4")
RolDE.res<-RolDE(data = data4, des_matrix = des_matrix4, doPar = T, n_cores = 3)
names(RolDE.res)
res.fin<-RolDE.res$RolDE_Results
View(res.fin)
RolDE.res2=RolDE(data = data4, des_matrix = des_matrix4, aligned = F, doPar = T, n_cores = 3)
a=RolDE.res[[1]]
b=RolDE.res[[2]]
a=a[order(as.numeric(a$`RolDE Rank Product`)),]
b=RolDE.res2[[1]]
b=b[order(as.numeric(b$`RolDE Rank Product`)),]
View(a)
View(b)
grep("ups", a[,1])
grep("ups", b[,1])
devtools::install_github("mathiaskalxdorf/IceR")
devtools::install_github("mathiaskalxdorf/IceR")
devtools::install_github("mathiaskalxdorf/IceR")
library(IceR)
runIceR()
runIceR()
runIceR()
ln
install.packages("C:/data/Seafile/My Library/Longitudinal Proteomics/RolDE/RolDE_0.0.1.000.tar.gz", repos = NULL, type = "source")
library(RolDE)
RolDE:::getSimRPs
library(RolDE)
?plotFindings
install.packages("C:/data/Seafile/My Library/Longitudinal Proteomics/RolDE/RolDE_0.0.2.000.tar.gz", repos = NULL, type = "source")
library(RolDE)
?plotF
detach("package:RolDE", unload=TRUE)
install.packages("C:/data/Seafile/My Library/Longitudinal Proteomics/RolDE/RolDE_0.0.2.000.tar.gz", repos = NULL, type = "source")
library(RolDE)
?plotF
load("C:/data/Seafile/My Library/Longitudinal Proteomics/RolDE/RolDE/data/data_descriptions.rda")
data_descriptions
load("C:/data/Seafile/My Library/Longitudinal Proteomics/RolDE/RolDE/data/data4.rda")
load("C:/data/Seafile/My Library/Longitudinal Proteomics/RolDE/RolDE/data/des_matrix4.rda")
aligned=T
min_comm_diff="auto"
min_ind_timep=3
min_feat_obs=3
degree_RegROTS="auto"
degree_PolyReg="auto"
B_for_ROTS=100
K_for_ROTS="auto"
rand_seed=1
na_treat="last"
n_cores=1
polyregType="fixed"
mix_degree=0
estSigVal=T
sigValSampN=500
sig_adj_meth="fdr"
add_refGroup=T
iter_polyDegree=F
weigh_runs=T
data=data4
des_matrix=des_matrix4
#Save input
input_list=list(data, des_matrix, min_comm_diff, min_ind_timep, min_feat_obs, degree_RegROTS, degree_PolyReg, B_for_ROTS, K_for_ROTS, rand_seed, na_treat, n_cores, polyregType, mix_degree, estSigVal, sigValSampN, sig_adj_meth, add_refGroup, iter_polyDegree, weigh_runs)
names(input_list)=c("data", "des_matrix", "min_comm_diff", "min_ind_timep", "min_feat_obs", "degree_RegROTS", "degree_PolyReg", "B_for_ROTS", "K_for_ROTS", "rand_seed", "na_treat", "n_cores", "polyregType", "mix_degree", "estSigVal", "sigValSampN", "sig_adj_meth", "add_refGroup", "iter_polyDegree", "weigh_runs")
#Validate design matrix and data
message("Validating input")
setwd("C:/data/Seafile/My Library/Longitudinal Proteomics/RolDE/RolDE/R")
source("validateAlignedData.R")
input_validated<-tryCatch(
{
validateAlignedData(data, des_matrix, min_comm_diff, min_ind_timep, min_feat_obs, B_for_ROTS, K_for_ROTS, rand_seed, na_treat, n_cores, polyregType, mix_degree, estSigVal, sigValSampN, sig_adj_meth, add_refGroup, iter_polyDegree, weigh_runs)
},
error=function(errorCond){
message("Execution halted with the following error:")
message(errorCond)
return(NULL)
}
)
#If problems during input validation
if(is.null(input_validated)){stop(cat("\nError during input validation\n"))}
data<-input_validated[[1]]
des_matrix<-input_validated[[2]]
test_type<-input_validated[[3]]
min_comm_diff<-input_validated[[4]]
message("Input validated.")
source("determineROTSRunsAligned.R")
#Determine ROTS runs
message("Preparing the Analysis")
rots_runs<-tryCatch(
{
determineROTSRunsAligned(data, des_matrix, test_type, min_comm_diff[1])
},
error=function(errorCond){
message("Execution halted with the following error:")
message(errorCond)
return(NULL)
}
)
source("utilFunctions.R")
#Determine ROTS runs
message("Preparing the Analysis")
rots_runs<-tryCatch(
{
determineROTSRunsAligned(data, des_matrix, test_type, min_comm_diff[1])
},
error=function(errorCond){
message("Execution halted with the following error:")
message(errorCond)
return(NULL)
}
)
#If problems during run determination
if(is.null(rots_runs)){stop(cat("\nError during determining ROTS runs\n"))}
#min_comm_diff<-rots_runs[[2]]
rots_runs<-rots_runs[[1]]
source("determineDegreesAligned.R")
#Validate and determine the degrees.
method_degrees<-tryCatch(
{
determineDegreesAligned(des_matrix, degree_RegROTS, degree_PolyReg)
},
error=function(errorCond){
message("Execution halted with the following error:")
message(errorCond)
return(NULL)
}
)
#If problems during degree determination
if(is.null(method_degrees)){stop(cat("\nError during degree determination\n"))}
degree_RegROTS<-method_degrees[[1]]
degree_PolyReg<-method_degrees[[2]]
source("RegROTS.R")
#Run RegROTS
message("Running RegROTS")
res_regrots<-tryCatch(
{
RegROTS(data, des_matrix, min_feat_obs, degree_RegROTS, rots_runs, B_for_ROTS, K_for_ROTS, rand_seed, na_treat, n_cores, add_refGroup, weigh_runs)
},
error=function(errorCond){
message("Execution halted with the following error:")
message(errorCond)
return(NULL)
}
)
n_cores=3
#Determine ROTS runs
message("Preparing the Analysis")
rots_runs<-tryCatch(
{
determineROTSRunsAligned(data, des_matrix, test_type, min_comm_diff[1])
},
error=function(errorCond){
message("Execution halted with the following error:")
message(errorCond)
return(NULL)
}
)
#If problems during run determination
if(is.null(rots_runs)){stop(cat("\nError during determining ROTS runs\n"))}
#min_comm_diff<-rots_runs[[2]]
rots_runs<-rots_runs[[1]]
#Validate and determine the degrees.
method_degrees<-tryCatch(
{
determineDegreesAligned(des_matrix, degree_RegROTS, degree_PolyReg)
},
error=function(errorCond){
message("Execution halted with the following error:")
message(errorCond)
return(NULL)
}
)
#If problems during degree determination
if(is.null(method_degrees)){stop(cat("\nError during degree determination\n"))}
degree_RegROTS<-method_degrees[[1]]
degree_PolyReg<-method_degrees[[2]]
#Run RegROTS
message("Running RegROTS")
res_regrots<-tryCatch(
{
RegROTS(data, des_matrix, min_feat_obs, degree_RegROTS, rots_runs, B_for_ROTS, K_for_ROTS, rand_seed, na_treat, n_cores, add_refGroup, weigh_runs)
},
error=function(errorCond){
message("Execution halted with the following error:")
message(errorCond)
return(NULL)
}
)
#If a problem arises during RegROTS
if(is.null(res_regrots)){stop(cat("\nError during RegROTS\n"))}
reg_rots_pval<-res_regrots[[1]]
if(weigh_runs){
regrots_weigths<-res_regrots[[3]]
}
res_regrots<-res_regrots[[2]]
#Run DiffROTS
message("Running DiffROTS")
res_diffrots<-tryCatch(
{
DiffROTSAligned(data, des_matrix, min_comm_diff[2], min_feat_obs, rots_runs, B_for_ROTS, K_for_ROTS, rand_seed, na_treat, n_cores, weigh_runs)
},
error=function(errorCond){
message("Execution halted with the following error:")
message(errorCond)
return(NULL)
}
)
source("DiffROTSAligned.R")
#Run DiffROTS
message("Running DiffROTS")
res_diffrots<-tryCatch(
{
DiffROTSAligned(data, des_matrix, min_comm_diff[2], min_feat_obs, rots_runs, B_for_ROTS, K_for_ROTS, rand_seed, na_treat, n_cores, weigh_runs)
},
error=function(errorCond){
message("Execution halted with the following error:")
message(errorCond)
return(NULL)
}
)
#If a problem arises during DiffROTS
if(is.null(res_diffrots)){stop(cat("\nError during DiffROTS\n"))}
diff_rots_pval<-res_diffrots[[1]]
if(weigh_runs){
diffrots_weigths<-res_diffrots[[3]]
}
res_diffrots<-res_diffrots[[2]]
source("PolyReg.R")
#Run PolyReg
message("Running PolyReg")
if(polyregType=="fixed"){
message("Running PolyReg with fixed effects only.")
res_polyreg<-tryCatch(
{
PolyReg(data, des_matrix, degree_PolyReg, n_cores, test_type, iter_polyDegree)
},
error=function(errorCond){
message("Execution halted with the following error:")
message(errorCond)
return(NULL)
}
)
}else{
message("Running PolyReg with mixed effects models.")
res_polyreg<-tryCatch(
{
PolyRegMix(data, des_matrix, degree_PolyReg, n_cores, test_type, mix_degree, iter_polyDegree)
},
error=function(errorCond){
message("Execution halted with the following error:")
message(errorCond)
return(NULL)
}
) #end trycatch PolyReg
}
#If a problem arises during PolyReg
if(is.null(res_polyreg)){stop(cat("\nError during PolyReg\n"))}
polyreg_pval<-res_polyreg[[1]]
res_polyreg<-res_polyreg[[2]]
#Now we should have everything to calculate the final rank product
message("Calculating the final rank product.")
rank_products<-tryCatch(
{
calculateRP(res_regrots, res_diffrots, res_polyreg, na_treat)
},
error=function(errorCond){
message("Execution halted with the following error:")
message(errorCond)
return(NULL)
}
)
source("calculateRP.R")
rank_products<-tryCatch(
{
calculateRP(res_regrots, res_diffrots, res_polyreg, na_treat)
},
error=function(errorCond){
message("Execution halted with the following error:")
message(errorCond)
return(NULL)
}
)
if(is.null(rank_products)){stop(cat("\nError during rank product calculation\n"))}
#Organize
res_regrots<-res_regrots[rownames(rank_products),]
res_diffrots<-res_diffrots[rownames(rank_products),]
res_polyreg<-res_polyreg[rownames(rank_products),]
reg_rots_pval<-reg_rots_pval[rownames(rank_products),]
diff_rots_pval<-diff_rots_pval[rownames(rank_products),]
polyreg_pval<-polyreg_pval[rownames(rank_products),]
if(!is.matrix(reg_rots_pval) & is.numeric(reg_rots_pval)){
reg_rots_pval=as.matrix(reg_rots_pval)
}
if(!is.matrix(diff_rots_pval) & is.numeric(diff_rots_pval)){
diff_rots_pval=as.matrix(diff_rots_pval)
}
if(!is.matrix(polyreg_pval) & is.numeric(polyreg_pval)){
polyreg_pval=as.matrix(polyreg_pval)
}
rp_reg<-as.numeric(res_regrots[,2])
rp_diff<-as.numeric(res_diffrots[,2])
p_poly<-as.numeric(res_polyreg[,2])
rank_reg<-rank(rp_reg,ties.method = "random", na.last = T) #CHECK ties.method
rank_diff<-rank(rp_diff,ties.method = "random", na.last = T)
rank_poly<-rank(p_poly,ties.method = "random", na.last = T)
names(rp_reg)<-rank_reg
names(rp_diff)<-rank_diff
names(p_poly)<-rank_poly
#create a uniform distribution of enough p-values
#sim_p<-seq(from=0, to=1, length.out = nrow(rank_products)*1000) #Should be enough?
sim_p=runif(n = nrow(rank_products)*1000)
summary(sim_p)
#create a uniform distribution of enough p-values
sim_p<-seq(from=0, to=1, length.out = nrow(rank_products)*1000) #Should be enough?
#sim_p=runif(n = nrow(rank_products)*1000)
all_poly_pvals=as.numeric(unlist(polyreg_pval)) #uniform if random data
ord_poly=rank(all_poly_pvals, na.last = T, ties.method = "random")
#Slightly faster single thread, but without seed or parallelism
#system.time({sim_rps<-replicate(n = sigValSampN, expr = {getSimRankProds(reg_rots_pval, diff_rots_pval, polyreg_pval, all_poly_pvals, ord_polu, sim_p, rp_reg, rp_diff, p_poly)})})
co<-NULL
sim_rps<-matrix(nrow = nrow(data), ncol = sigValSampN)
cl <- parallel::makeCluster(n_cores)
stopcluster
stopCluster(cl)
parallel::stopCluster(cl)
used_seed<-rand_seed+co
co
co=1
used_seed<-rand_seed+co
#always repeatable seeds, but different for each individual sample.
seed1<-rand_seed
used_seed
sigValSampN
sigValSampN
length(rank_products)
nrow(rank_products)
sigValSampN=500000
sigValSampN
sigValSampN=500000
sigValSampN/nrow(rank_products)
ceiling(sigValSampN/nrow(rank_products))
sigValSampN=500000
#Organize
res_regrots<-res_regrots[rownames(rank_products),]
res_diffrots<-res_diffrots[rownames(rank_products),]
res_polyreg<-res_polyreg[rownames(rank_products),]
reg_rots_pval<-reg_rots_pval[rownames(rank_products),]
diff_rots_pval<-diff_rots_pval[rownames(rank_products),]
polyreg_pval<-polyreg_pval[rownames(rank_products),]
if(!is.matrix(reg_rots_pval) & is.numeric(reg_rots_pval)){
reg_rots_pval=as.matrix(reg_rots_pval)
}
if(!is.matrix(diff_rots_pval) & is.numeric(diff_rots_pval)){
diff_rots_pval=as.matrix(diff_rots_pval)
}
if(!is.matrix(polyreg_pval) & is.numeric(polyreg_pval)){
polyreg_pval=as.matrix(polyreg_pval)
}
rp_reg<-as.numeric(res_regrots[,2])
rp_diff<-as.numeric(res_diffrots[,2])
p_poly<-as.numeric(res_polyreg[,2])
rank_reg<-rank(rp_reg,ties.method = "random", na.last = T) #CHECK ties.method
rank_diff<-rank(rp_diff,ties.method = "random", na.last = T)
rank_poly<-rank(p_poly,ties.method = "random", na.last = T)
names(rp_reg)<-rank_reg
names(rp_diff)<-rank_diff
names(p_poly)<-rank_poly
#create a uniform distribution of enough p-values
sim_p<-seq(from=0, to=1, length.out = nrow(rank_products)*1000) #Should be enough?
all_poly_pvals=as.numeric(unlist(polyreg_pval)) #uniform if random data
ord_poly=rank(all_poly_pvals, na.last = T, ties.method = "random")
#Slightly faster single thread, but without seed or parallelism
#system.time({sim_rps<-replicate(n = sigValSampN, expr = {getSimRankProds(reg_rots_pval, diff_rots_pval, polyreg_pval, all_poly_pvals, ord_polu, sim_p, rp_reg, rp_diff, p_poly)})})
co<-NULL
sigValSampN<-ceiling(sigValSampN/nrow(rank_products))
sim_rps<-matrix(nrow = nrow(data), ncol = sigValSampN)
used_seed<-rand_seed+co
#always repeatable seeds, but different for each individual sample.
seed1<-rand_seed
seed2<-rand_seed+(sigValSampN+1)
seed3<-rand_seed+((sigValSampN*2)+1)
seq(1:sigValSampN)
seq(from=2, to=sigValSampN+1)
a=seq(from=2, to=sigValSampN+1)
rand_seed=2
#always repeatable seeds, but different for each individual sample.
seed1<-rand_seed
seed2<-rand_seed+(sigValSampN+1)
seed3<-rand_seed+((sigValSampN*2)+1)
a[length(a)]
rand_seed=318
seed1
seed2
seed3
#always repeatable seeds, but different for each individual sample.
seed1<-rand_seed
seed2<-rand_seed+(sigValSampN+1)
seed3<-rand_seed+((sigValSampN*2)+1)
seed1
seed2
seed3
rand_seed=500
a=seq(from=501, to=500+sigValSampN)
a
rand_seed=501
#always repeatable seeds, but different for each individual sample.
seed1<-rand_seed
seed2<-rand_seed+(sigValSampN+1)
seed3<-rand_seed+((sigValSampN*2)+1)
seed1
seed2
seed3
rand_seed=100
rand_seed=1000
rand_seed=15000
#always repeatable seeds, but different for each individual sample.
seed1<-rand_seed
seed2<-rand_seed+(sigValSampN+1)
seed3<-rand_seed+((sigValSampN*2)+1)
seed1
seed2
seed3
