locs_na<-which(is.na(row[which(groups_for_rots==group)]))
locs_nonna<-which(!is.na(row[which(groups_for_rots==group)]))
if(length(locs_nonna)<2){
imp.num<-2-length(locs_nonna)
#set.seed(rand_seed)
vals<-sample(all_num_values, length(imp.num), replace = T)
row[which(groups_for_rots==group)][locs_na][1:imp.num]<-vals
}
}
coef_scaled[r,]<-row
}
ref_group<-data.frame(matrix(nrow = nrow(coef_scaled), ncol = length(which(groups_for_rots==1))))
fillGapsAll_New
fillGaps_New
fillGapsAll_New
ref_group<-data.frame(matrix(nrow = nrow(coef_scaled), ncol = length(which(groups_for_rots==1))))
#Fill compeletely in with random values from the distribution of all differences
for(r in 1:nrow(ref_group)){
row<-ref_group[r,]
seed_for_imp<-rand_seed+r
locs_na<-which(is.na(row))
set.seed(seed_for_imp)
vals<-sample(all_num_values, length(locs_na), replace = T)
ref_group[r,]<-vals
}
View(ref_group)
#Add a zeroish reference group to compare to.
ref_group<-data.frame(matrix(nrow = nrow(coef_scaled), ncol = length(which(groups_for_rots==1))))
#Fill compeletely in with random values from the distribution of all differences
for(r in 1:nrow(ref_group)){
row<-ref_group[r,]
seed_for_imp<-rand_seed+r
ref_group[r,]<-fillGapsAll_New(all_quant_vals = all_quant_vals, row = row, rand_seed = seed_for_imp)
}
View(ref_group)
ref_group1=ref_group
ref_group<-data.frame(matrix(nrow = nrow(coef_scaled), ncol = length(which(groups_for_rots==1))))
#Fill compeletely in with random values from the distribution of all differences
for(r in 1:nrow(ref_group)){
row<-ref_group[r,]
seed_for_imp<-rand_seed+r
locs_na<-which(is.na(row))
set.seed(seed_for_imp)
vals<-sample(all_num_values, length(locs_na), replace = T)
ref_group[r,]<-vals
}
ref_group<-data.frame(matrix(nrow = nrow(coef_scaled), ncol = length(which(groups_for_rots==1))))
#Fill compeletely in with random values from the distribution of all differences
for(r in 1:nrow(ref_group)){
row<-ref_group[r,]
seed_for_imp<-rand_seed+r
locs_na<-which(is.na(row))
set.seed(seed_for_imp)
vals<-sample(all_num_values, length(locs_na), replace = T)
ref_group[r,]<-vals
}
hist(as.numeric(ref_group1))
hist(as.numeric(unlist(ref_group1)))
hist(as.numeric(unlist(ref_group)))
summary(as.numeric(unlist(ref_group1)))
summary(as.numeric(unlist(ref_group)))
#Make a new dataset and update groups for ROTS
coef_new<-cbind(coef_scaled, ref_group)
groups_for_rots_org=groups_for_rots
groups_for_rots<-c(groups_for_rots, rep((max(groups_for_rots)+1), length(which(groups_for_rots==1))))
colnames(coef_new)<-groups_for_rots
#Perform multigroup ROTS
#determine K
if(K_for_ROTS=="auto"){
K_for_ROTS<-nrow(coef_new)/4
}
suppressMessages(expr = {rots_out<-ROTS::ROTS(data = coef_new, groups = groups_for_rots, B = B_for_ROTS, K = K_for_ROTS, paired = F, seed = rand_seed, progress = F)})
rots.out2=rots_out
a=data.frame(rots_out1$d, rots_out1$pvalue)
b=data.frame(rots_out2$d, rots_out2$pvalue)
rots_out2=rots_out
a=data.frame(rots_out1$d, rots_out1$pvalue)
b=data.frame(rots_out2$d, rots_out2$pvalue)
hist(a$rots_out1.pvalue)
hist(b$rots_out2.pvalue)
View(a)
View(b)
##another way
coef_scaled=coef_scaled_org
#make the imputation repeatable
for(r in 1:nrow(coef_scaled)){
row<-coef_scaled[r,]
seed_for_imp<-rand_seed+r
for(group in 1:max(groups_for_rots)){
locs_na<-which(is.na(row[which(groups_for_rots==group)]))
locs_nonna<-which(!is.na(row[which(groups_for_rots==group)]))
if(length(locs_nonna)<2){
imp.num<-2-length(locs_nonna)
#set.seed(rand_seed)
vals<-sample(all_num_values2, length(imp.num), replace = T)
row[which(groups_for_rots==group)][locs_na][1:imp.num]<-vals
}
}
coef_scaled[r,]<-row
}
groups_for_rots=groups_for_rots_org
#make the imputation repeatable
for(r in 1:nrow(coef_scaled)){
row<-coef_scaled[r,]
seed_for_imp<-rand_seed+r
for(group in 1:max(groups_for_rots)){
locs_na<-which(is.na(row[which(groups_for_rots==group)]))
locs_nonna<-which(!is.na(row[which(groups_for_rots==group)]))
if(length(locs_nonna)<2){
imp.num<-2-length(locs_nonna)
#set.seed(rand_seed)
vals<-sample(all_num_values2, length(imp.num), replace = T)
row[which(groups_for_rots==group)][locs_na][1:imp.num]<-vals
}
}
coef_scaled[r,]<-row
}
ref_group<-data.frame(matrix(nrow = nrow(coef_scaled), ncol = length(which(groups_for_rots==1))))
#Fill compeletely in with random values from the distribution of all differences
for(r in 1:nrow(ref_group)){
row<-ref_group[r,]
seed_for_imp<-rand_seed+r
locs_na<-which(is.na(row))
set.seed(seed_for_imp)
vals<-sample(all_num_values2, length(locs_na), replace = T)
ref_group[r,]<-vals
}
#Make a new dataset and update groups for ROTS
coef_new<-cbind(coef_scaled, ref_group)
groups_for_rots<-c(groups_for_rots, rep((max(groups_for_rots)+1), length(which(groups_for_rots==1))))
colnames(coef_new)<-groups_for_rots
#Perform multigroup ROTS
#determine K
if(K_for_ROTS=="auto"){
K_for_ROTS<-nrow(coef_new)/4
}
suppressMessages(expr = {rots_out<-ROTS::ROTS(data = coef_new, groups = groups_for_rots, B = B_for_ROTS, K = K_for_ROTS, paired = F, seed = rand_seed, progress = F)})
rots_out3=rots_out #all_num_values2
c=data.frame(rots_out3$d, rots_out3$pvalue)
hist(c$rots_out3.pvalue)
hist(a$rots_out1.pvalue)
hist(b$rots_out2.pvalue)
hist(c$rots_out3.pvalue)
#mitä jos ottaa all_num_values2 ja ala-ylä kvartiili
summary(all_num_values2)
all_num_values3=all_num_values2[which(all_num_values2>quantile(all_num_values2,0.25) & all_num_values2<quantile(all_num_values2,0.75))]
summary(all_num_values3)
coef_scaled=coef_scaled_org
groups_for_rots=groups_for_rots_org
#make the imputation repeatable
for(r in 1:nrow(coef_scaled)){
row<-coef_scaled[r,]
seed_for_imp<-rand_seed+r
for(group in 1:max(groups_for_rots)){
locs_na<-which(is.na(row[which(groups_for_rots==group)]))
locs_nonna<-which(!is.na(row[which(groups_for_rots==group)]))
if(length(locs_nonna)<2){
imp.num<-2-length(locs_nonna)
#set.seed(rand_seed)
vals<-sample(all_num_values3, length(imp.num), replace = T)
row[which(groups_for_rots==group)][locs_na][1:imp.num]<-vals
}
}
coef_scaled[r,]<-row
}
ref_group<-data.frame(matrix(nrow = nrow(coef_scaled), ncol = length(which(groups_for_rots==1))))
#Fill compeletely in with random values from the distribution of all differences
for(r in 1:nrow(ref_group)){
row<-ref_group[r,]
seed_for_imp<-rand_seed+r
locs_na<-which(is.na(row))
set.seed(seed_for_imp)
vals<-sample(all_num_values3, length(locs_na), replace = T)
ref_group[r,]<-vals
}
coef_new<-cbind(coef_scaled, ref_group)
groups_for_rots<-c(groups_for_rots, rep((max(groups_for_rots)+1), length(which(groups_for_rots==1))))
colnames(coef_new)<-groups_for_rots
suppressMessages(expr = {rots_out<-ROTS::ROTS(data = coef_new, groups = groups_for_rots, B = B_for_ROTS, K = K_for_ROTS, paired = F, seed = rand_seed, progress = F)})
rots_out4=rots_out #all_num_values2
a=data.frame(rots_out1$d, rots_out1$pvalue)
b=data.frame(rots_out2$d, rots_out2$pvalue)
c=data.frame(rots_out3$d, rots_out3$pvalue)
d=data.frame(rots_out4$d, rots_out4$pvalue)
hist(a$rots_out1.pvalue)
hist(b$rots_out2.pvalue)
hist(c$rots_out3.pvalue)
hist(d$rots_out4.pvalue)
cor(a$rots_out1.pvalue, b$rots_out1.pvalue, method = "spearman")
as.numeric(a$rots_out1.pvalue)
cor(as.numeric(a$rots_out1.pvalue), as.numeric(b$rots_out1.pvalue), method = "spearman")
cor(as.numeric(a$rots_out1.pvalue), as.numeric(b$rots_out2.pvalue), method = "spearman")
cor(as.numeric(a$rots_out1.pvalue), as.numeric(c$rots_out3.pvalue), method = "spearman")
cor(as.numeric(a$rots_out2.pvalue), as.numeric(b$rots_out3.pvalue), method = "spearman")
cor(as.numeric(b$rots_out2.pvalue), as.numeric(c$rots_out3.pvalue), method = "spearman")
hist(a$rots_out1.pvalue)
hist(b$rots_out2.pvalue)
hist(c$rots_out3.pvalue)
data=data4
des_matrix=des_matrix4
#Validate design matrix and data
message("Validating input")
input_validated<-tryCatch(
{
validateInput(data, des_matrix, aligned, min_comm_diff, min_feat_obs, B_for_ROTS, K_for_ROTS, rand_seed, na_treat, n_cores, model_type, sigValSampN, sig_adj_meth)
},
error=function(errorCond){
message("Execution halted with the following error:")
message(errorCond)
return(NULL)
}
)
min_comm_diff
source("validateInput.R")
source("validateInput.R")
#Validate design matrix and data
message("Validating input")
input_validated<-tryCatch(
{
validateInput(data, des_matrix, aligned, min_comm_diff, min_feat_obs, B_for_ROTS, K_for_ROTS, rand_seed, na_treat, n_cores, model_type, sigValSampN, sig_adj_meth)
},
error=function(errorCond){
message("Execution halted with the following error:")
message(errorCond)
return(NULL)
}
)
#If problems during input validation
if(is.null(input_validated)){stop(cat("\nError during input validation\n"))}
data<-input_validated[[1]]
des_matrix<-input_validated[[2]]
min_comm_diff<-input_validated[[3]]
model_type<-input_validated[[4]]
estSigVal<-input_validated[[5]]
message("Input validated")
#Determine ROTS runs
message("Preparing the Analysis")
rots_runs<-tryCatch(
{
determineROTSRuns(data, des_matrix, min_comm_diff[1])
},
error=function(errorCond){
message("Execution halted with the following error:")
message(errorCond)
return(NULL)
}
)
#If problems during run determination
if(is.null(rots_runs)){stop(cat("\nError during determining ROTS runs\n"))}
rots_runs<-rots_runs[[1]]
#Validate and determine the degrees.
method_degrees<-tryCatch(
{
determineDegrees(des_matrix, degree_RegROTS, degree_PolyReg)
},
error=function(errorCond){
message("Execution halted with the following error:")
message(errorCond)
return(NULL)
}
)
#If problems during degree determination
if(is.null(method_degrees)){stop(cat("\nError during degree determination\n"))}
degree_RegROTS<-method_degrees[[1]]
degree_PolyReg<-method_degrees[[2]]
degree_RegROTS
degree_PolyReg
degree<-degree_RegROTS
unique_conditions<-unique(as.character(des_matrix[,2]))
#Determine case and control. Control is always the first condition encountered in the design matrix.
#Doesn't really matter.
control<-unique_conditions[1]
case<-unique_conditions[2]
#The main function to compare coefficients
getCoef<-function(r1, r2, time1, time2, degree, thres_feat_both_cond, min_feat_obs) {
if( sum(!is.na(r1))<min_feat_obs | sum(!is.na(r2))<min_feat_obs | sum(is.na(c(r1,r2)))>thres_feat_both_cond ){
diffs<-rep(NA, degree+1)
} else {
if(any(is.na(r1))){
time1<-time1[-which(is.na(r1))]
r1<-r1[-which(is.na(r1))]
}
if(any(is.na(r2))){
time2<-time2[-which(is.na(r2))]
r2<-r2[-which(is.na(r2))]
}
if((length(time1)-1)>=degree){d1<-degree}else{d1<-length(time1)-1}
if((length(time2)-1)>=degree){d2<-degree}else{d2<-length(time2)-1}
mod1<-tryCatch({
lm(as.numeric(r1)~poly(time1,(d1)))
},error = function(e) {
NULL
})
mod2<-tryCatch({
lm(as.numeric(r2)~poly(time2,(d2)))
},error = function(e) {
NULL
})
if(is.null(mod1) | is.null(mod2)){
diffs<-rep(NA, degree+1)
} else {
coeffs1<-mod1$coefficients
coeffs2<-mod2$coefficients
diffs<-numeric(degree+1)
diffs[1:(min(d1,d2, na.rm = T)+1)]<-coeffs1[1:(min(d1,d2, na.rm = T)+1)]-coeffs2[1:(min(d1,d2, na.rm = T)+1)]
diffs[diffs==0]<-NA
}
}
return(diffs)
}
run=1
rots_res_frame=matrix(nrow=nrow(data), ncol = length(rots_runs))
#Determine groups for ROTS
run_comparisons<-rots_runs[[run]]
replicate_comparisons<-ncol(run_comparisons)
groups_for_rots<-sort(rep(seq(1:(degree+1)),replicate_comparisons))
#Get the sample locations (columns) for the individuals in the comparisons for the current run.
control_locs<-list()
case_locs<-list()
#Store the timepoints for each individual in each comparison here
times_control<-list()
times_case<-list()
for(comp in 1:ncol(run_comparisons)){
control_locs[[comp]]<-which(des_matrix$Individual%in%run_comparisons[1,comp])
case_locs[[comp]]<-which(des_matrix$Individual%in%run_comparisons[2,comp])
times_control[[comp]]=des_matrix$Timepoint[control_locs[[comp]]]
times_case[[comp]]=des_matrix$Timepoint[case_locs[[comp]]]
}
#A data frame to save the coefficient differences in.
coef_frame<-data.frame(matrix(nrow = nrow(data), ncol = replicate_comparisons*(degree+1)))
rownames(coef_frame)<-rownames(data)
colnames(coef_frame)<-groups_for_rots
for(r in 1:nrow(data)) {
res_row<-numeric(ncol(coef_frame))
for(comp in 1:ncol(run_comparisons)){
cont_loc<-control_locs[[comp]]
case_loc<-case_locs[[comp]]
row_control<-data[r,cont_loc]
row_case<-data[r,case_loc]
time_control<-times_control[[comp]]
time_case<-times_case[[comp]]
thres_feat_both_cond<-(length(time_control)+length(time_case))-4 #Internal threshold. Guarantees the filtering away extreme scenarios. Doesn't really play a role? To be removed in the future?
res_vals<-getCoef(r1 = row_case, r2 = row_control, time1 = time_case, time2 = time_control, degree = degree, thres_feat_both_cond = thres_feat_both_cond, min_feat_obs = min_feat_obs)
res_row[seq(from=comp, to=length(res_row), by=replicate_comparisons)]=res_vals
} #end comparison loop
coef_frame[r,]<-res_row
} #end getting coefficients for rows
#Scale the coefficients differences within each group to acquire similar distributions for correct testing in ROTS
coef_scaled<-data.frame(matrix(nrow = nrow(coef_frame), ncol = ncol(coef_frame)))
rownames(coef_scaled)<-rownames(coef_frame)
colnames(coef_scaled)<-colnames(coef_frame)
coef_scaled_org=coef_scaled
groups_for_rots_org=groups_for_rots
for(group in 1:max(groups_for_rots)){
data_temp<-coef_frame[, which(groups_for_rots==group)]
data_temp<-as.numeric(unlist(data_temp))
data_temp<-data_temp/sd(data_temp, na.rm = T)
coef_scaled[,which(groups_for_rots==group)]<-data_temp
}
#Remove features with noth enough values in the first two groups, intercept (expression) level
#differences and differences in longitudinal linear patterns of expression.
#Require at least two values for group, 2 required for ROTS.
rem_feat<-numeric(0)
for(group in 1:2){ #so we need to remove those that have too many nas in group 1 or 2
rem_feat<-c(rem_feat,which(apply(coef_scaled[,which(groups_for_rots==group)], 1, function(x) (sum(!is.na(x))<2))))
}
rem_feat<-unique(rem_feat)
#Save and remove the possible removed features
if(length(rem_feat)>0){
rem_names<-rownames(coef_scaled)[rem_feat] #save these and input back into the results
coef_scaled<-coef_scaled[-rem_feat,]
}
#Make sure that each group has enough values for ROTS. While each protein is required
#to have enough numerical difference values in the first two groups in the prior step,
#the rest of the group might have insufficient number of values. Furthermore,
#each feature is required to have the same number of groups. So in each group
#for each feature, if not at least two difference values per group exist,
#some random values are imputed from the total distribution of differences over
#all features and groups. Since most of the features are not typically
#differentially expressed, most of these values are near zero. Now uses all values,
#could also be values between quantiles 0.25-0.75, so more pronounced zero values. Change if needed.
all_num_values<-as.numeric(unlist(coef_scaled))
all_num_values<-na.omit(all_num_values)
#get enough quantile values used for imputation
all_quant_vals<-quantile(all_num_values, seq(from=0.001, to=1, by=0.001))
coef_scaled_org=coef_scaled
groups_for_rots_org=groups_for_rots
#make the imputation repeatable
for(r in 1:nrow(coef_scaled)){
row<-coef_scaled[r,]
seed_for_imp<-rand_seed+r
coef_scaled[r,]<-fillGaps_New(all_quant_vals = all_quant_vals, row = row, groups_for_rots = groups_for_rots, rand_seed = seed_for_imp)
}
#Add a zeroish reference group to compare to.
ref_group<-data.frame(matrix(nrow = nrow(coef_scaled), ncol = length(which(groups_for_rots==1))))
#Fill compeletely in with random values from the distribution of all differences
for(r in 1:nrow(ref_group)){
row<-ref_group[r,]
seed_for_imp<-rand_seed+r
ref_group[r,]<-fillGapsAll_New(all_quant_vals = all_quant_vals, row = row, rand_seed = seed_for_imp)
}
#Make a new dataset and update groups for ROTS
coef_new<-cbind(coef_scaled, ref_group)
groups_for_rots<-c(groups_for_rots, rep((max(groups_for_rots)+1), length(which(groups_for_rots==1))))
colnames(coef_new)<-groups_for_rots
#Perform multigroup ROTS
#determine K
if(K_for_ROTS=="auto"){
K_for_ROTS<-nrow(coef_new)/4
}
suppressMessages(expr = {rots_out<-ROTS::ROTS(data = coef_new, groups = groups_for_rots, B = B_for_ROTS, K = K_for_ROTS, paired = F, seed = rand_seed, progress = F)})
rots_out1=rots.out
ts_out1=rots_out
rots_out1=rots_out
#zero center
diff<-mean(all_num_values)-0
all_num_values2<-all_num_values-diff
##another way
coef_scaled=coef_scaled_org
groups_for_rots=groups_for_rots_org
#make the imputation repeatable
for(r in 1:nrow(coef_scaled)){
row<-coef_scaled[r,]
seed_for_imp<-rand_seed+r
for(group in 1:max(groups_for_rots)){
locs_na<-which(is.na(row[which(groups_for_rots==group)]))
locs_nonna<-which(!is.na(row[which(groups_for_rots==group)]))
if(length(locs_nonna)<2){
imp.num<-2-length(locs_nonna)
#set.seed(rand_seed)
vals<-sample(all_num_values2, length(imp.num), replace = T)
row[which(groups_for_rots==group)][locs_na][1:imp.num]<-vals
}
}
coef_scaled[r,]<-row
}
ref_group<-data.frame(matrix(nrow = nrow(coef_scaled), ncol = length(which(groups_for_rots==1))))
#Fill compeletely in with random values from the distribution of all differences
for(r in 1:nrow(ref_group)){
row<-ref_group[r,]
seed_for_imp<-rand_seed+r
locs_na<-which(is.na(row))
set.seed(seed_for_imp)
vals<-sample(all_num_values2, length(locs_na), replace = T)
ref_group[r,]<-vals
}
#Make a new dataset and update groups for ROTS
coef_new<-cbind(coef_scaled, ref_group)
groups_for_rots<-c(groups_for_rots, rep((max(groups_for_rots)+1), length(which(groups_for_rots==1))))
groups_for_rots
colnames(coef_new)<-groups_for_rots
#Perform multigroup ROTS
#determine K
if(K_for_ROTS=="auto"){
K_for_ROTS<-nrow(coef_new)/4
}
suppressMessages(expr = {rots_out<-ROTS::ROTS(data = coef_new, groups = groups_for_rots, B = B_for_ROTS, K = K_for_ROTS, paired = F, seed = rand_seed, progress = F)})
rots_out2=rots_out #all_num_values
a=data.frame(rots_out1$d, rots_out1$pvalue)
b=data.frame(rots_out2$d, rots_out2$pvalue)
hist(a$rots_out1.pvalue)
hist(b$rots_out2.pvalue)
cor(as.numeric(a$rots_out1.pvalue), as.numeric(b$rots_out2.pvalue), method = "spearman")
unique_conditions<-unique(as.character(des_matrix[,2]))
#Determine case and control. Control is always the first condition encountered in the design matrix. Need to be changed?
control<-unique_conditions[1]
case<-unique_conditions[2]
rots_frame=matrix(nrow = nrow(data), ncol = degree_PolyReg+1)
d=0
r=1
r=2
temp_data<-matrix(nrow = nrow(des_matrix), ncol = 5)
temp_data<-data.frame(temp_data, stringsAsFactors = F)
colnames(temp_data)<-c("Intensity", "Time", "Condition", "Block", "Individual")
temp_data[,1]<-as.numeric(as.character(data[r,]))
temp_data[,2]<-as.numeric(as.character(des_matrix$Timepoint))
temp_data[,3]<-as.factor(des_matrix$Condition)
temp_data[,4]<-as.factor(as.numeric(as.character(des_matrix$Block)))
temp_data[,5]<-as.factor(as.numeric(as.character(des_matrix$Individual)))
rownames(temp_data)<-colnames(data)
View(temp_data)
temp_data<-matrix(nrow = nrow(des_matrix), ncol = 4)
temp_data<-data.frame(temp_data, stringsAsFactors = F)
colnames(temp_data)<-c("Intensity", "Time", "Condition", "Individual")
temp_data[,1]<-as.numeric(as.character(data[r,]))
temp_data[,2]<-as.numeric(as.character(des_matrix$Timepoint))
temp_data[,3]<-as.factor(des_matrix$Condition)
temp_data[,5]<-as.factor(as.numeric(as.character(des_matrix$Individual)))
rownames(temp_data)<-colnames(data)
View(temp_data)
colnames(des_matrix)
temp_data<-matrix(nrow = nrow(des_matrix), ncol = 4)
temp_data<-data.frame(temp_data, stringsAsFactors = F)
colnames(temp_data)<-c("Intensity", "Time", "Condition", "Individual")
temp_data[,1]<-as.numeric(as.character(data[r,]))
temp_data[,2]<-as.numeric(as.character(des_matrix$Timepoint))
temp_data[,3]<-as.factor(des_matrix$Condition)
temp_data[,4]<-as.factor(as.numeric(as.character(des_matrix$Individual)))
rownames(temp_data)<-colnames(data)
View(temp_data)
mod1<-tryCatch({
nlme::lme(Intensity~1, random = ~ 1 | Individual, data=temp_data, na.action = na.omit, method = "REML",control = lmeControl(opt = 'optim'))
},error = function(e) {
NULL
})
mod1
lme(Intensity~1, random = ~ 1 | Individual, data=temp_data, na.action = na.omit, method = "REML",control = lmeControl(opt = 'optim'))
library(nlme)
lme(Intensity~1, random = ~ 1 | Individual, data=temp_data, na.action = na.omit, method = "REML",control = lmeControl(opt = 'optim'))
lme(Intensity~Time, random = ~ 1 | Individual, data=temp_data, na.action = na.omit, method = "REML",control = lmeControl(opt = 'optim'))
degree_PolyReg
nlme::lme(Intensity~1, random = ~ Time | Individual, data=temp_data, na.action = na.omit, method = "REML",control = lmeControl(opt = 'optim', msMaxIter=500))
